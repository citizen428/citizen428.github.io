<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | citizen428.blog()]]></title>
  <link href="http://citizen428.net/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://citizen428.net/"/>
  <updated>2013-09-01T23:23:22+08:00</updated>
  <id>http://citizen428.net/</id>
  <author>
    <name><![CDATA[Michael Kohl]]></name>
    <email><![CDATA[citizen428@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Extending Nmap with Lua]]></title>
    <link href="http://citizen428.net/blog/2013/08/31/extending-nmap-with-lua/"/>
    <updated>2013-08-31T17:49:00+08:00</updated>
    <id>http://citizen428.net/blog/2013/08/31/extending-nmap-with-lua</id>
    <content type="html"><![CDATA[<p><em>I originally wrote this piece for a pentesting magazine, but after some unprofessional behavior by their editor I lost my cool and decided not too publish it there. It&rsquo;d be a shame to let it go to waste though, so I after almost three month I finally decided to put it up on my blog.</em></p>

<p>Whether you are working as a security professional or a network administrator, chances are that <a href="http://nmap.org/">Nmap</a> (“Network Mapper”) is part of your regular toolkit. For many people this project, which was started by Gordon &ldquo;Fyodor&rdquo; Lyon in 1997, is the first choice when it comes to host and service discovery. But thanks to the Nmap Scripting Engine (NSE), it can do much more than that, allowing users to easily develop and share their own scripts, thus turning it into a versatile security scanner.</p>

<h3>What you will learn&hellip;</h3>

<ul>
<li>basics of the Lua programming language,</li>
<li>walkthrough of a simple NSE script,</li>
<li>where to find more information on scripting Nmap and Lua in general.</li>
</ul>


<h3>What you should know&hellip;</h3>

<ul>
<li>basic Nmap usage,</li>
<li>an imperative programming language.</li>
</ul>


<h3>The Nmap Scripting Engine (NSE)</h3>

<p>Scripting has been part of Nmap for a while, but version 6 includes a dramatically improved implementation of the NSE infrastructure. This also led to an enormous increase in <a href="http://nmap.org/nsedoc/">available scripts</a>, from 59 in version 5, to 347 in the latest release and more than 430 in the current SVN repository. The core of NSE is an embedded Lua interpreter. Before NSE’s implementation started, the Nmap developers considered various programming languages for inclusion, but finally settled on Lua because it&rsquo;s small, liberally licensed (MIT), fast, actively developed and designed with embeddability in mind. It&rsquo;s also used in other popular FOSS security tools like <a href="http://www.wireshark.org">Wireshark</a> and <a href="http://snort.org/">Snort</a>, as well as in popular projects such as <em>World of Warcraft</em> or the window manager <a href="http://awesome.naquadah.org/">Awesome</a>.</p>

<h2>The Lua Programming Language</h2>

<p>Development of <a href="http://lua.org/">Lua</a> started in 1993 at the Pontifical Catholic University of Rio de Janeiro, Brazil. It was designed by Roberto Ierusalimschy, Waldemar Celes and Luiz Henrique de Figueiredo, with the primary goals of being lightweight, cross-platform and easy to embed in other projects. These goals were achieved by writing the language in portable ISO C and giving it a comparatively simple C API. Also Lua&rsquo;s interpreter only takes up about 180 kB in compiled form, so embedding it does not incur a huge cost. Over the years it became a popular scripting and extension language, used in a wide variety of projects. The syntax of Lua should be familiar to anyone who has experience in Modula or C style languages (control structures like <em>if</em>, <em>while</em>, <em>for</em>), but the designers borrowed liberally from other languages as well: the semantics of Lua are heavily influenced by Scheme, and even though the different syntax obscures this a bit, it becomes rather clear the longer you use the language. In some ways it feels like a cleaner and better designed JavaScript, so it&rsquo;s normally
easy to understand a given snippet of Lua code even with little or no previous exposure to the language.</p>

<h3>Key features</h3>

<p>Lua features first-class functions, thus allowing the developer to treat functions like any other data type. It also doesn&rsquo;t impose a certain programming paradigm, but instead provides meta-features to extend the language as needed. This for example makes it possible to implement things like inheritance in a rather simple and straightforward way without explicit language support. Lua is also garbage collected, features closures and proper tails calls and provides an infrastructure for cooperative multitasking in the form of coroutines. While most of this goes beyond the scope of this article (and NSE), interested readers can find more information in the excellent book &ldquo;Programming in Lua&rdquo;, <a href="http://www.lua.org/pil/">an older version of which is available for free on the project&rsquo;s web site</a>.</p>

<h3>Tables</h3>

<p>There&rsquo;s is however one more feature of Lua that&rsquo;s worth discussing in a bit more detail, namely its reliance on a single compound data structure, the table. Tables are in essence what other languages commonly refer to as associative arrays or dictionaries, or key-value pairs. This is how you create a simple table:</p>

<p>{% codeblock lang:lua %}
{% raw %}
table = { x = 10, y = &ldquo;foo&rdquo; }
{% endraw %}
{% endcodeblock %}</p>

<p>The values can be accessed like this: <em>t[&ldquo;x&rdquo;]</em> and <em>t[&ldquo;y&rdquo;]</em>. For string keys Lua supports a nice shorthand though, so <em>t.x</em> and <em>t.y</em> will produce the same result.</p>

<p>One special feature of Lua&rsquo;s tables is that they are also optimized for use as arrays, which can be created like this:</p>

<p>{% codeblock lang:lua %}
{% raw %}
array = { &ldquo;citizen&rdquo;, &ldquo;428&rdquo;, &ldquo;blog&rdquo; }
{% endraw %}
{% endcodeblock %}</p>

<p>Indices are assigned automatically and unlike in other languages start from 1, not 0 (although it is possible to explicitly assign to <em>array[0]</em>). So to get the string &ldquo;428&rdquo; out of our array, we have to use <em>array[2]</em>.</p>

<p>With this comparatively simple data structure (and the powerful metatable feature) Lua not only implements arrays and dictionaries, but also records/structs, namespaces, classes, objects and much more.</p>

<h3>Examples</h3>

<p>Enough theory, let’s look at some example Lua code. First the customary “Hello world” program:</p>

<p>{% codeblock lang:lua %}
print “Hello world”
{% endcodeblock %}</p>

<p>This will just output <em>Hello world</em>. Now for a function definition:</p>

<p>{% codeblock lang:lua %}
function sayHello(name)
  print (&ldquo;Hello &rdquo; .. name .. &ldquo;!&rdquo;)
end
{% endcodeblock %}</p>

<p>To generate the same output as above, we would have to call the function with the appropriate argument: <em>sayHello(“world”)</em>. Alternatively, the same function could be defined like this:</p>

<p>{% codeblock lang:lua %}
sayHello = function(name)
  print (&ldquo;Hello &rdquo; .. name .. &ldquo;!&rdquo;)
end
{% endcodeblock %}</p>

<p>Last but not least a small loop that iterates over an array and prints out each element (<em>ipairs</em> returns the index-value pairs of an array):</p>

<p>{% codeblock lang:lua %}
for i, str in ipairs(array) do
  print (i..&ldquo;: &rdquo;..str)
end
{% endcodeblock %}</p>

<p>Assuming the variable <em>array</em> contains the elements “citizen”, “428”, and “blog”, this will generate the following output:</p>

<pre><code>1: citizen
2: 428
3: blog
</code></pre>

<h2>NSE example script</h2>

<p>The Nmap web site contains some excellent documentation regarding NSE (<a href="http://nmap.org/book/man-nse.html">short intro</a>, <a href="http://nmap.org/book/nse.html">full book chapter</a>, <a href="http://nmap.org/book/nse-tutorial.html">tutorial</a>, so instead of repeating all of what’s written there, we’ll look at a practical example instead. The script shown here is <a href="http://nmap.org/nsedoc/scripts/http-generator.html">http_generator.nse</a>, which looks for the presence of an HTTP <em>generator</em> meta tag to determine which CMS the scanned hosts run (if any). This information can be useful, since outdated versions of such systems are common attack vectors.</p>

<h3>Library imports</h3>

<p>{% codeblock lang:lua %}
local http = require &ldquo;http&rdquo;
local shortport = require &ldquo;shortport&rdquo;
local stdnse = require &ldquo;stdnse&rdquo;
local string = require &ldquo;string&rdquo;
{% endcodeblock %}</p>

<p>It&rsquo;s customary to start Nmap scripts by importing all the needed <a href="http://nmap.org/book/nse-library.html">libraries</a>. In the process they are assigned to local variables, so if you wanted to access them under a different (presumably shorter) name you could do so (for example <em>local s = require “string”</em>). There&rsquo;s a wide variety of available libraries, from protocols (<em>afp</em>, <em>dns</em>, <em>http</em>, <em>bitcoin</em>, <em>openssl</em> etc.) over encoding/decoding (<em>base32</em>, <em>base64</em>, <em>json</em>) and utility libraries (<em>nmap</em>, <em>packet</em>, <em>pcre</em>) to a framework for brute-force attacks against services (<em>brute</em>).
The script we are looking at uses the <em>http</em> library for communication, <em>shortport</em> for an easier way to define portrules (more on that later), and <em>stdnse</em>, a collection of utility functions provided by NSE. The <em>string</em> library is a standard Lua library and used for string matching in this example.</p>

<h3>Metadata</h3>

<p>{% codeblock lang:lua %}
description = [[ Displays the contents of the &ldquo;generator&rdquo; meta tag of a web page(default: /) if there is one.
]]</p>

<p>author = &ldquo;Michael Kohl&rdquo;
license = &ldquo;Same as Nmap&mdash;See <a href="http://nmap.org/book/man-legal.html">http://nmap.org/book/man-legal.html</a>&rdquo;
categories = {&ldquo;default&rdquo;, &ldquo;discovery&rdquo;, &ldquo;safe&rdquo;}</p>

<hr />

<p>&mdash; @usage</p>

<h2>&mdash; nmap &mdash;script http-generator [&mdash;script-args http-generator.path=<path>,http-generator.redirects=<number>,&hellip;] <host></h2>

<p>&mdash; @output
&mdash; PORT    STATE SERVICE
&mdash; 80/tcp  open  http
&mdash; |_http-generator: TYPO3 4.2 CMS
&mdash; 443/tcp open  https</p>

<h2>&mdash; |_http-generator: TYPO3 4.2 CMS</h2>

<p>&mdash; @args http-generator.path Specify the path you want to check for a generator meta tag (default to &lsquo;/&rsquo;).
&mdash; @args http-generator.redirects Specify the maximum number of redirects to follow (defaults to 3).</p>

<p>&mdash; Changelog:
&mdash; 2011-12-23 Michael Kohl <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#99;&#x69;&#x74;&#x69;&#x7a;&#101;&#110;&#52;&#50;&#56;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#x63;&#x69;&#116;&#x69;&#122;&#x65;&#110;&#x34;&#50;&#56;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a>:
&mdash;   + Initial version
&hellip;
{% endcodeblock %}</p>

<p>After the library imports, scripts contain some metadata that is used for documentation and internal purposes. The <em>description</em> and author variables are self-explanatory, the syntax used for the former is Lua&rsquo;s way of creating so-called &ldquo;heredocs&rdquo;, string literals that preserve white space and line breaks. In regard to the <em>license</em> script authors have two choices, the GPL-like Nmap license, as well as a simplified (2-clause) BSD license. Last but not least there&rsquo;s documentation in the NSEDoc format. It&rsquo;s customary to include usage documentation, example output, descriptions of all the available arguments (if any) as well as a changelog.</p>

<p>There&rsquo;s another important field that this specific script doesn&rsquo;t use, <em>dependencies</em>. This defines the order in which scripts should be run and is used for the case where one script works on the results of another script. It&rsquo;s important to keep in mind that scripts listed here will not be automatically run, they still have to be selected via <em>&mdash;script scriptname</em> or in another way (for example <em>&mdash;script=default</em>).</p>

<p>The <em>categories</em> variable is a bit more interesting, it defines which groups of scripts our current program belongs to. Scripts marked as <em>default</em> will be run automatically when Nmap is started with the <em>-sC</em> or <em>-A</em> options.To qualify for inclusion in this category, scripts have to adhere to some criteria: they need to be fast, reliable, non-obstrusive and generally useful. There are no clear definitions for these criteria, it&rsquo;s up to the Nmap developers to add a script to this category. The <em>discovery</em> category collects all scripts that actively try to gather more information about the scan targets, in our case the &ldquo;generator&rdquo; HTML meta tag. If a script is marked as <em>safe</em>, that means that it was not written with the intent of crashing services or exploiting vulnerabilities and that it&rsquo;s unlikely to consume large amounts of resources. There are many more categories Nmap uses, for example <em>auth</em> (scripts dealing with authentication credentials), <em>brute</em> (tools for brute force attacks) or <em>vuln</em> (checking for specific vulnerabilities). For a full list, please consult Nmap&rsquo;s excellent documentation.</p>

<p>Now that we know a bit more about categories, let&rsquo;s see how we can use that knowledge for more interesting Nmap runs. Let’s start by running all the default scripts:</p>

<p>{% codeblock lang:bash %}
nmap -sC example.com
{% endcodeblock %}</p>

<p>or</p>

<p>{% codeblock lang:bash %}
nmap &mdash;script=default example.com
{% endcodeblock %}</p>

<p>The invocation <em>nmap -A example.com</em> (&ldquo;Aggressive/advanced scan options&rdquo;) enables OS and version detection, script scanning (equivalent to <em>nmap -sC</em>), and traceroute.</p>

<p>If you just want to run a single script, you can do so by specifying the <em>&mdash;script</em> argument, for example <em>nmap &mdash;script http-generator example.com</em>.</p>

<p>It’s also possible to run scripts from several categories, by using something like <em>nmap &mdash;script &ldquo;default,safe&rdquo; example.com</em> or <em>nmap &mdash;script &ldquo;default or safe&rdquo; example.com</em>. There is an analogous and operator, so <em>nmap &mdash;script &ldquo;default AND safe&rdquo; example.com</em> will only run scripts that are in all the listed categories.</p>

<p>As an example for a rather complex invocation, the following command will run all scripts from the three specified categories, except for the ones whose name starts with &ldquo;http-&rdquo;.</p>

<p>{% codeblock lang:bash %}
nmap &mdash;script &ldquo;(default or safe or intrusive) and not http-*&rdquo; example.com
{% endcodeblock %}</p>

<p>Last but not least it’s also possible to run user scripts which are not part of the standard Nmap distribution, as show in the following example:</p>

<p>{% codeblock lang:bash %}
nmap &mdash;script default,banner,/home/user/customscripts example.com
{% endcodeblock %}</p>

<p>The above invocation will run all default scripts, the script named “banner” and all scripts which can be found in the directory <em>/home/user/customscripts</em>.</p>

<h3>Rule</h3>

<p>The <em>rule</em> definition is an important part of every NSE script, it determines when the script should run. A rule is a Lua function that returns <em>true</em> or <em>false</em> to decide whether or not the script&rsquo;s action function will be executed. There are several different rule types, depending on when the script is supposed to run (before or after hosts are scanned, <em>prerule</em> and <em>postrule</em>) or if the trigger is a specific host or port (<em>hostrule</em> and <em>portrule</em>).</p>

<p>The rule definition in our example script is very simple since it uses the very handy <em>shortport</em> library, which has several predefined rules for common scenarios:</p>

<p>{% codeblock lang:lua %}
rule = shortport.http
{% endcodeblock %}</p>

<p>This will match and return <em>true</em> when a given port is likely to be an HTTP port.</p>

<h3>Action</h3>

<p>{% codeblock lang:lua %}
action = function(host, port)</p>

<pre><code>local path = stdnse.get_script_args('http-generator.path') or '/'
local redirects = tonumber(stdnse.get_script_args('http-generator.redirects')) or 3

-- Worst case: &lt;meta name=Generator content="Microsoft Word 11"&gt;
local pattern = '&lt;meta name="?generator"? content="([^\"]*)" ?/?&gt;'

-- make pattern case-insensitive
pattern = pattern:gsub("%a", function (c)
              return string.format("[%s%s]", c, string.upper(c))
          end)

local response = follow_redirects(host, port, path, redirects)
if ( response and response.body ) then
    return response.body:match(pattern)
end
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>The <em>action</em> function is the heart of every NSE script, it contains the code that will be performed when the rule matches. Basically <em>action</em> is just another Lua function that accepts the same arguments as the <em>rule</em> function (which is not as obvious in our example because of the use of the <em>shortport.http</em> rule).</p>

<p>The function starts with checking for the presence of two arguments and specifies defaults in case the user didn’t provide any values for them. Arguments can be passed to the script in the following way:</p>

<p>{% codeblock lang:lua %}
nmap &mdash;script http-generator &mdash;script-args http-generator.path=/cms,http-generator.redirects=2 example.com
{% endcodeblock %}</p>

<p>They get stored in the table <em>nmap.registry.args</em>, but instead of using them directly you should use the function <em>stdnse.get_script_args</em> to access them.</p>

<p>After the argument handling, a pattern matching the HTTP &ldquo;meta&rdquo; tag is specified. Standard Lua does not include a regular expression library, but uses its own patterns instead. While there is a library providing Perl-compatible regular expressions (PCRE) for Nmap, it seemed like overkill to drag it in for a single expression, so I relied on plain Lua for this, which explains the little workaround used in the next line to make the pattern case insensitive by replacing every letter (the pattern <em>%a</em>) with its lower and upper case version.
After that the <em>follow_redirects</em> helper function is used to get an HTTP response, and if there is one, its body will be scanned for our pattern.</p>

<p>If there is a match, the function will return the matching string and Nmap will automatically include it in its output as shown here:</p>

<pre><code>PORT   STATE SERVICE
80/tcp open  http
| _http-generator: WordPress.com |
</code></pre>

<p>Instead of a string the action can also return tables consisting of name-value pairs which are then formatted in a structured fashion, whereas the return value <em>nil</em> generates no output at all.</p>

<p>As you may have noticed I didn’t yet show you the helper function mentioned above, so while it’s not very interesting in itself, I’ll include it for completeness’ sake:</p>

<p>{% codeblock lang:lua %}
local follow_redirects = function(host, port, path, n)</p>

<pre><code>local loc
local pattern = "^[hH][tT][tT][pP]/1.[01] 30[12]"
local response = http.get(host, port, path)
while (response['status-line'] or ""):match(pattern) and n &gt; 0 do
    n = n - 1
    loc = response.header['location']
    response = http.get_url(loc)
end
return response
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>This helper function is a simple way to follow HTTP redirects. It first defines a pattern for recognizing the relevant HTTP status codes (301 and 302) before making a request to the specified host, port and path combination. It then checks for the presence of a redirect and if there is one, follows it to retrieve the location information from the new location. When there are no more redirects or the redirect limit (specified in the argument <em>n</em>) has been reached, the function returns the full HTTP response to the caller.</p>

<h3>Digging deeper</h3>

<p>And that’s all there is to it! Thanks to the excellent infrastructure provided by NSE and all its libraries, writing custom Nmap scripts is a pretty easy and straightforward task. Anybody with a bit of scripting experience should be able to pick up the basics in a very short time and then learn about the finer points while developing scripts. The Nmap development team has assembled some excellent documentation which can be found online at <a href="http://nmap.org/book/nse.html.">http://nmap.org/book/nse.html.</a> There’s also a great presentation by Fyodor and Nmap co-maintainer David Fifield available <a href="http://nmap.org/presentations/BHDC10/">online</a> which gets you started on developing your own NSE scripts in less than an hour.</p>

<h2>Summary</h2>

<p>Nmap is a popular tool for security and network professionals around the world, and its excellent scripting capabilities make it very versatile. The Nmap Scripting Engine relies on the popular and easy to learn Lua programming language, and provides useful libraries for quickly and efficiently developing your own custom scripts, which can then be shared with the wider Nmap user community.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Information Overload 2012-09-09]]></title>
    <link href="http://citizen428.net/blog/2012/09/09/information-overload-2012-09-09/"/>
    <updated>2012-09-09T00:00:00+08:00</updated>
    <id>http://citizen428.net/blog/2012/09/09/information-overload-2012-09-09</id>
    <content type="html"><![CDATA[<p>I was rather busy this week, so this Information Overload is super short.</p>

<ul>
<li><a href="http://lubutu.com/soso/condition-handling-for-non-lispers">Condition Handling for Non-Lispers</a><br>If you ever need to explain condition handling to a non-Lisper, this is a sensible post to point them too.</li>
<li><a href="http://www.handelsblatt.com/politik/oekonomie/nachrichten/vollgeld-iwf-forscher-spielen-radikale-bankreform-durch-seite-all/7008170-all.html">IWF-Forscher spielen radikale Bankreform durch</a><br>Two IMF economist test a model where banks can&rsquo;t create new money in the form of loans (in German).</li>
<li><a href="http://news.discovery.com/history/preserved-brain-bog-england-110406.html">Prehistoric human brain found pickled in bog</a><br>A bit older, but still very insteresting for science.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby — Left section for infix operators]]></title>
    <link href="http://citizen428.net/blog/2012/07/30/ruby-left-section-for-infix-operators/"/>
    <updated>2012-07-30T23:24:00+08:00</updated>
    <id>http://citizen428.net/blog/2012/07/30/ruby-left-section-for-infix-operators</id>
    <content type="html"><![CDATA[<p>Let me admit right away that this is yet another &ldquo;because I can&rdquo; type of post with little practical use. With that out of the way, today&rsquo;s topic is <a href="http://www.haskell.org/haskellwiki/Section_of_an_infix_operator">sections of infix operators</a> as known from e.g. Haskell. Here&rsquo;s an example:</p>

<p>{% codeblock lang:haskell %}
λ> map (2+) [1..3]
[3,4,5]
{% endcodeblock %}</p>

<p>As you can see the function to be <code>map</code>ped is specified with the <a href="http://www.haskell.org/haskellwiki/Partial_application">partially applied</a> function <code>(2+)</code> (or <code>(+2)</code> for that matter).</p>

<p>Here&rsquo;s how we would have to write the same code in Ruby:</p>

<p>{% codeblock lang:ruby %}
(1..3).map { |i| i + 2 }
{% endcodeblock %}</p>

<p>This could also be written in a <a href="http://www.haskell.org/haskellwiki/Pointfree">pointfree</a> way, but alas that would make the code rather hard to understand for less experienced Rubyists:</p>

<p>{% codeblock lang:ruby %}
(1..3).map(&amp;2.method(:+))
{% endcodeblock %}</p>

<p>But because Ruby is as flexible as it is, adding partial application is actually really trivial:</p>

<p>{% codeblock lang:ruby %}
class Fixnum
  alias :add :+</p>

<p>  def +(o=nil)</p>

<pre><code>o ? self.add(o) : lambda { |x| self + x }
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>And now we can do this:</p>

<p>{% codeblock lang:ruby %}
(1..3).map(&amp;2.+) #=> [3, 4, 5]
{% endcodeblock %}</p>

<p>Not too bad I think and rather consistent with Ruby&rsquo;s overall style. Alas I don&rsquo;t think we are likely to see partial application on a language level any time soon though&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Review: Ruby and MongoDB Web Development]]></title>
    <link href="http://citizen428.net/blog/2012/07/28/review-ruby-and-mongodb-web-development/"/>
    <updated>2012-07-28T10:15:00+08:00</updated>
    <id>http://citizen428.net/blog/2012/07/28/review-ruby-and-mongodb-web-development</id>
    <content type="html"><![CDATA[<p><em>Disclaimer:</em> I was one of the technical editors of this book, so I may be biased.</p>

<p>While I haven&rsquo;t received <a href="http://www.packtpub.com/ruby-and-mongodb-web-development-beginners-guide/book">the book</a> in its final form yet, I&rsquo;ve read all of it, and I can say that the author does a good job at introducing inexperienced programmers to web development with Ruby and MongoDB.</p>

<p>This is a hands-on book and you&rsquo;ll get most out of it by following all the exercises and doing them on your own. From getting all the necessary components and installing them, to developing apps with Sinatra and Rails, a lot of ground is covered.</p>

<p>While the author does tackle some more advanced topics, they are clearly not the focus of this book (it&rsquo;s subtitled &ldquo;Beginner&rsquo;s Guide&rdquo; for a reason) which will leave more experienced developers wanting for more. However, the presented material is well written, chapters build on each other and if you are new to web development with Ruby/RoR and/or MongoDB, this is a good title to get you up to speed in just 300 pages.</p>

<p>If you are a more experienced Ruby developer or are already very familiar with MongoDB, this is probably not the book for you, even though you&rsquo;ll probably still get something out of it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shenanigans]]></title>
    <link href="http://citizen428.net/blog/2012/07/03/shenanigans/"/>
    <updated>2012-07-03T19:46:00+08:00</updated>
    <id>http://citizen428.net/blog/2012/07/03/shenanigans</id>
    <content type="html"><![CDATA[<p>About 1.5 month ago I finally packaged some of my Ruby extension methods into the aptly named <a href="https://rubygems.org/gems/shenanigans">Shenanigans</a> gem. It&rsquo;s similar to <a href="http://rubyworks.github.com/facets/">Facets</a> or <a href="http://as.rubyonrails.org/">ActiveSupport</a>, but probably less useful to most people. Also some of the methods actually are in Facets, although sometimes with different names or slightly different semantics. Anyway, since some people told me they actually do like the gem, here&rsquo;s a quick summary of what the different methods do and how they can be useful.</p>

<ul>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Array:%5E">Array#^</a>: Ruby defines <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/set/rdoc/Set.html#method-i-5E">Set#^</a>, which returns the elements exclusive between the set and a given enum. Since a lot of people use arrays instead of proper sets in Ruby, I found it makes a nice addition to <a href="http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-7C">Array#|</a> and <a href="http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-26">Array#&amp;</a>.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Array:random_subarray">Array#random_subarray</a>: Generates one or more random subarrays of an array, using the fact that Ruby can index integers to get the bit values to ensure fast uniform distributions. Similar to <a href="http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-sample">Array#sample</a>, but can generate several subarrays at once.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Array:zip_with">Array#zip_with</a>: The more general form of <code>zip</code> (e.g. in Haskell you could define <code>zip = zipWith (,)</code>). Like Ruby&rsquo;s <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject">Enumerable#inject</a> it can take a symbol argument or a block, and like Haskell&rsquo;s <code>zip</code> it discards excess array elements if one list is shorter than the other, whereas Ruby&rsquo;s <a href="http://www.ruby-doc.org/core-1.9.3/Array.html#method-i-zip">Array#zip</a> only does that if the receiver is shorter than the argument (it adds <code>nil</code>s in the other case).</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Hash:has_shape%3F">Hash#has_shape?</a>: A quick way to check if a hash&rsquo;s keys are of certain classes. This does feel a bit strange in a duck-typed language like Ruby, but someone asked for it on StackOverflow and it was easy enough to write. This could be useful in validations or unit tests though.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Hash:to_ostruct">Hash#to_ostruct</a>: I really like the <a href="https://github.com/railsjedi/rails_config">rails_config</a> gem. I therefore decided to write something that gives me similar functionality (although a lot simpler) for plain Ruby projects. Basically this recursively converts a hash and all nested hashes into <a href="http://ruby-doc.org/stdlib-1.9.3/libdoc/ostruct/rdoc/OpenStruct.html">OpenStruct</a> instances. Populate the hash with Ruby&rsquo;s <a href="http://corelib.rubyonrails.org/classes/YAML.html">YAML</a> support and you have an instant settings object.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Kernel:fn">Kernel#fn</a>: I admit, this was more of a &ldquo;because I can&rdquo; method. Originally I wrote this so I could compose blocks in <a href="http://www.haskell.org/haskellwiki/Pointfree">pointfree style</a>, but later added support for <a href="http://www.ruby-doc.org/core-1.9.3/Proc.html">Proc</a> instances too.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Kernel:prompt">Kernel#prompt</a>: While it&rsquo;s great that Ruby&rsquo;s <a href="http://www.ruby-doc.org/core-1.9.3/IO.html#method-i-gets">IO#gets</a> is so general, I always wanted something like Python&rsquo;s <a href="http://docs.python.org/library/functions.html#raw_input">raw_input</a> for command line apps. Additionally you can also automatically call any of the numeric conversions, and I&rsquo;m pondering adding support for every unary string method.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Kernel:with">Kernel#with</a>: I think <a href="http://ruby-doc.org/core-1.9.3/Object.html#method-i-tap">Object#tap</a> is great. However, I sometimes see it used as a replacement for <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-inject">Enumerable#inject</a> or <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-each_with_object">Enumerable#each_with_object</a>, but for some reason I never really liked the semantics of it. And since I&rsquo;m anal about that sort of thing I added this Pascal/ActionScript like <code>with</code> statement.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Object:display">Object#display</a>: Having no proper object-oriented way to print objects in Ruby always kinda bothered me, so I abused <a href="http://ruby-doc.org/core-1.9.3/Object.html#method-i-tap">Object#tap</a> as a wrapper around <a href="http://www.ruby-doc.org/core-1.9.3/Kernel.html#method-i-puts">Kernel#puts</a> and <a href="http://www.ruby-doc.org/core-1.9.3/Kernel.html#method-i-print">Kernel#print</a>. Additionally this is aliased to the name <code>d</code>, which I stole from <a href="https://github.com/janlelis/irbtools">irbtools</a>. The latter form makes it great for debugging method chains and the likes.</p></li>
<li><p><a href="http://rubydoc.info/gems/shenanigans/1.0.4/Object:it">Object#it</a>: I always disliked blocks of the form <code>{ |x| x }</code> that sometimes crop up when using  <a href="http://ruby-doc.org/core-1.9.3/Enumerable.html#method-i-group_by">Enumerable#group_by</a> or similar methods. Since Ruby lacks an identity method and <code>id</code> has historically been taken, I decided to name it <code>it</code>.</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
