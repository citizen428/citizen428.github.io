<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mongodb | citizen428.blog()]]></title>
  <link href="http://citizen428.net/blog/categories/mongodb/atom.xml" rel="self"/>
  <link href="http://citizen428.net/"/>
  <updated>2012-11-12T19:50:31-02:00</updated>
  <id>http://citizen428.net/</id>
  <author>
    <name><![CDATA[Michael Kohl]]></name>
    <email><![CDATA[citizen428@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fun With Twitter and MongoDB]]></title>
    <link href="http://citizen428.net/blog/2011/10/28/fun-with-twitter-and-mongodb/"/>
    <updated>2011-10-28T20:36:00-02:00</updated>
    <id>http://citizen428.net/blog/2011/10/28/fun-with-twitter-and-mongodb</id>
    <content type="html"><![CDATA[<p>I'm currently reading the early access version of <a href="http://www.manning.com/banker/">MongoDB in Action</a>, so I felt like playing around with it a bit (in fact I do use it for <a href="http://happynerds.net">Happynerds.net</a>, but that's not very exciting). I then remembered that I recently stumbled upon a service called <a href="http://export.synack.me/">The Exporter</a>, which I had used to download all my tweets from Twitter (as of October 4th 2011). So why not use MongoDB to find out which users I retweet most often?</p>

<!-- more -->


<p>Since the data provided by The Exporter is already in JSON format, it should be really easy to import it using the <code>mongoimport</code> tool:</p>

<p>{% codeblock lang:bash %}
mongoimport -d twitter -c tweets twitter-statuses-citizen428.json
{% endcodeblock %}</p>

<p>Alas this just threw a lot of errors at me and said that no records got imported. A quick look at the <a href="http://www.mongodb.org/display/DOCS/Import+Export+Tools">relevant documentation</a> shows that <code>mongoimport</code> expects one JSON object per line, so I had to remove the opening and closing bracket on the first and last line respectively, as well as the commas separating the lines (<code>s/,$//</code>). Once I did this, the import worked as expected and I had several thousand tweets in the collection <code>tweets</code> in the database <code>twitter</code>.</p>

<p>Since I'll most likely do similar imports in the future, I added a <a href="http://www.mongodb.org/display/DOCS/Indexes#Indexes-UniqueIndexes">unique index</a> on the field named <code>id</code> (note that this is different from Mongo's built in <code>_id</code>):</p>

<p>{% codeblock lang:javascript %}
db.tweets.ensureIndex({id: 1}, {unique: true});
{% endcodeblock %}</p>

<p>I also added a <a href="http://www.mongodb.org/display/DOCS/Indexes#Indexes-SparseIndexes">sparse index</a> on <code>in_reply_to_screen_name</code>, the most important field for what I was about to do:</p>

<p>{% codeblock lang:javascript %}
db.tweets.ensureIndex({in_reply_to_screen_name: 1}, {sparse: true});
{% endcodeblock %}</p>

<p>For getting the actual data I wanted, MongoDB's built-in <a href="http://www.mongodb.org/display/DOCS/MapReduce">map/reduce functionality</a> seemed like a perfect fit. Here's the mapping function, in all it's glory:</p>

<p>{% codeblock lang:javascript %}
m = function () {
  emit({user:this.in_reply_to_screen_name}, {count:1});
}
{% endcodeblock %}</p>

<p>The reduce step is equally simple:</p>

<p>{% codeblock lang:javascript %}
r = function (k, v) {
  var count = 0;
  v.forEach(function (value) {count += value.count;});
  return {count:count};
}
{% endcodeblock %}</p>

<p>To make the actual <code>mapReduce</code> invocation more readable, I decided to also save the query in a separate object:</p>

<p>{% codeblock lang:javascript %}
q = { "in_reply_to_screen_name" : { "$ne" : null } }
{% endcodeblock %}</p>

<p>With all the pieces in place, I could run <code>mapReduce</code> to put the result in a new collection named <code>top_retweets</code>:</p>

<p>{% codeblock lang:javascript %}
db.tweets.mapReduce(m, r, {out: "top_retweets", query: q});
{% endcodeblock %}</p>

<p>Querying the freshly created collection, sorting it in reverse order of <code>value.count</code> and limiting the result set to 10 elements gave me the top 10 users I retweet (note that this data is most likely not entirely accurate, since The Exporter only got me around 3.2k of the roughly 5k tweets I had at that time):</p>

<p>{% codeblock lang:javascript %}
db.top_retweets.find({}).sort({"value.count":-1}).limit(10);
{ "<em>id" : { "user" : "MrJaba" }, "value" : { "count" : 53 } }
{ "</em>id" : { "user" : "leyrer" }, "value" : { "count" : 52 } }
{ "<em>id" : { "user" : "cypher" }, "value" : { "count" : 38 } }
{ "</em>id" : { "user" : "MSch" }, "value" : { "count" : 34 } }
{ "<em>id" : { "user" : "kewagi" }, "value" : { "count" : 25 } }
{ "</em>id" : { "user" : "IORayne" }, "value" : { "count" : 23 } }
{ "<em>id" : { "user" : "berenguel" }, "value" : { "count" : 22 } }
{ "</em>id" : { "user" : "kaleidic" }, "value" : { "count" : 20 } }
{ "<em>id" : { "user" : "antifuchs" }, "value" : { "count" : 19 } }
{ "</em>id" : { "user" : "ofalk" }, "value" : { "count" : 19 } }
{% endcodeblock %}</p>

<p>Hm, this is a collection I'll most likely query more in the future, how did the above query perform? Not so well I'm afraid:</p>

<p>{% codeblock lang:javascript %}
db.top_retweets.find({}).sort({"value.count":-1}).limit(10).explain();
{</p>

<pre><code>"cursor" : "BasicCursor",
"nscanned" : 192,
"nscannedObjects" : 192,
"n" : 10,
"scanAndOrder" : true,
"millis" : 0,
"nYields" : 0,
"nChunkSkips" : 0,
"isMultiKey" : false,
"indexOnly" : false,
"indexBounds" : {

}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>The most important thing to note here is the difference between the number of documents (<code>nscanned</code>, 192) and the actual number returned (<code>n</code>, 10). Also the query had to order the result for us (indicated by <code>"scanAndOrder" : true</code>). Fortunately that's nothing another index can't fix, this time a reverse one on <code>value.count</code>:</p>

<p>{% codeblock lang:javascript %}
db.top_retweets.ensureIndex({"value.count": -1});
db.top_retweets.find({}).sort({"value.count":-1}).limit(10).explain();
{</p>

<pre><code>"cursor" : "BtreeCursor value.count_-1",
"nscanned" : 10,
"nscannedObjects" : 10,
"n" : 10,
"millis" : 0,
"nYields" : 0,
"nChunkSkips" : 0,
"isMultiKey" : false,
"indexOnly" : false,
"indexBounds" : {
    "value.count" : [
        [
            {
                "$maxElement" : 1
            },
            {
                "$minElement" : 1
            }
        ]
    ]
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>All in all this was a pretty fun little exercise, that proves how easy it is to go from JSON to queryable data with MongoDB. I'll probably do more of this in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fun with Sinatra, Heroku and MongoDB]]></title>
    <link href="http://citizen428.net/blog/2009/12/06/fun-with-sinatra-heroku-and-mongodb/"/>
    <updated>2009-12-06T00:00:00-02:00</updated>
    <id>http://citizen428.net/blog/2009/12/06/fun-with-sinatra-heroku-and-mongodb</id>
    <content type="html"><![CDATA[<p>I've been toying around with the idea for a small website lately, but never actually got around to do it. In an attempt to clear out my personal to do list I finally motivated myself to start yesterday, and I have to say the following combination of tools is not only insanely efficient, but also really fun to work with:</p>

<ul>
<li><a href="http://www.sinatrarb.com/">Sinatra</a>, <i>&#8220;a DSL for quickly creating web applications in Ruby with minimal effort&#8221;</i>. I recommend using it in combination with <a href="http://mongrel.rubyforge.org/">Mongrel</a>, <a href="http://github.com/rtomayko/shotgun">Shotgun</a> and <a href="http://haml-lang.com/">Haml</a>.</li><br />
<li><a href="http://heroku.com/">Heroku</a>, a Ruby cloud hosting platform. Small sites are for free and Heroku&#8217;s git-based workflow just feels so natural. You can also <a href="http://docs.heroku.com/gems">manage your gem dependencies</a> and <a href="http://docs.heroku.com/config-vars">set up environment variables</a>, which made my life a whole lot easier.</li><br />
<li><a href="http://www.mongodb.org">MongoDB</a>, <i>&#8220;a scalable, high-performance, open source, schema-free, document-oriented database&#8221;</i>. In this specific case I used <a href="http://www.mongohq.com/home">MongoHQ</a> for the database hosting, since they were nice enough to provide me with a beta account. I stored all the connection information for MongoHQ in environment variables as described above:</p>
<script src="http://gist.github.com/250193.js?file=mongohq.rb"></script>
</ul>


<p>With this combination I was able to go from zero to mostly finished (I still need to write some of the content and make/steal a stylesheet) in very little time, while actually having fun! Thanks everybody for providing the Ruby community which such awesome tools! :-)</p>
]]></content>
  </entry>
  
</feed>
